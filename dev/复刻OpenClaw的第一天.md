# 复刻 OpenClaw 的第一天

## 一、为什么我要自己做一个

前段时间，我看到了 OpenClaw 这个项目。简单说，它是一个「跑在你电脑上的 AI 助理」——不依赖大厂云端，自己部署，自己控制数据；能接 WhatsApp、Telegram、Slack 等你已经在用的聊天工具；更重要的是，它不只是陪你聊天，而是能**真的干活**：帮你执行命令、读写文件、查网页、记事情。

我本职是做 Agent 的。所谓 Agent，可以理解成「会自己选工具、一步步完成任务」的 AI，而不是问一句答一句的聊天窗口。看到 OpenClaw 之后，我第一反应是：这东西很可能是一个分水岭。

大家常说 AI 的「iPhone 时刻」——指的往往是某款产品让技术从极客玩具变成普通人也能用的拐点。我觉得，对「Agent」来说，OpenClaw 所代表的方向，就有那么一点这种意思：一个跑在自己环境里、能接各种渠道、又能真干活的个人助理，很可能在未来几年里，真的改变很多人工作和协作的方式。所以我对它的前景非常看好，也特别想亲手摸清里面的每一层是怎么运转的。

那为什么还要自己做一个，而不是直接用 OpenClaw？

一是**身份**：我是 Agent 开发工程师。只有把「接收消息 → 会话管理 → 调用大模型 → 选工具 → 执行 → 再回消息」这条链路自己搭一遍，才能吃透每一环的细节，以后做别的 Agent 产品心里才有底。

二是**需求**：OpenClaw 面向的是「所有用户」，要兼容很多渠道、很多客户端、很多安全策略，所以架构会偏重、偏全。而我只需要服务自己（顶多身边几个人），用飞书就够了，不需要那么多抽象和开关。自己做一个，可以大刀阔斧地砍掉用不到的部分，只留真正要用的能力。

三是**掌控感**：哪里不满意就改哪里，不用等上游合并 PR，也不用被「官方路线图」牵着走。代码在自己手里，迭代节奏也在自己手里。

所以我就决定：**借 OpenClaw 的灵魂，走自己的路**——按它的核心思路（ReAct、记忆、技能、工具体系、多模型容错等）来设计，但实现上做减法，只做「飞书 + 个人用」的版本，并且从第一天起就按「每天都能在飞书里看到真实进展」来推进。

决定好方向之后，说实话挺激动的：想法有了，但要落地，还得先把「怎么做」想清楚。在真正动手写代码之前，我做了两件很重要的事。

---

## 二、动手之前的两件大事

**第一件事：读了一遍 OpenClaw 的源码，然后自己写了一份 ClawBot 的技术方案。**

光看介绍和文档不够，得真的钻进代码里，看它怎么收消息、怎么调大模型、怎么选工具、怎么管会话和记忆。读完之后，我按照「只保留自己需要的、去掉用不到的」的思路，把整体架构、各层职责、模块之间怎么衔接，都写进了一份技术方案里。这样做的目的很简单：落笔写代码之前，先有一张「地图」，不至于写着写着发现架构推倒重来。技术方案里会涉及网关、内核、Agent 执行、工具与记忆这些大块，但具体实现细节这里就不展开了，留到真正写代码时再抠。

**第二件事：把整个复刻过程拆成了七天的工期。**

我给自己定了一个原则：**每一天结束时，都能在飞书里体验到真实的新进展**。不追求完美，先让每一层骨架跑通，再回头补细节。于是七天大致是这样安排的：

- **第一天**：接通飞书，跑通第一句对话——你发一句，机器人能回一句。
- **第二天**：会说话，还能记住——多轮对话、会话历史、队列都接上，重启之后历史还在。
- **第三天**：有了灵魂——给机器人人格设定（SOUL）和技能描述（Skills），说话有了风格和能力边界。
- **第四天**：真正能干活——能执行命令、读写文件、编辑文件，从「只会聊」变成「能动手」。
- **第五天**：能上网了——接入搜索和网页抓取，能查最新信息、抓网页内容。
- **第六天**：有了真正的记忆——跨会话的记忆，你告诉它的事，下次新开对话它还记得。
- **第七天**：认识你了——用户画像自动积累、多模型容错、上下文压缩，再加插件骨架，系统稳定可用。

这样拆完，心里就有数了：每天一个小目标，七天下来，从「能回一句话」到「一个真正好用、可迭代的个人助理」。今天这篇，就是第一天的记录。

---

## 三、第一天我想达到什么

目标很朴素：**在飞书里给机器人发一条消息，它能用大模型智能回复你。**

换句话说：  
你发「你好」→ 机器人回一句像人、且和上下文有关的回复；  
你发任意问题 → 它都能正经回答，而不是报错或乱码。

要做到这一点，背后至少要打通几条线：

1. **有一个能跑起来的服务**  
   用 TypeScript + 一个轻量的 Web 框架（我选了 Hono）把 HTTP 服务拉起来，用 PM2 做进程守护，保证挂了能自动重启。

2. **能接到飞书发来的消息**  
   飞书通过「Webhook」把用户消息推给你的服务器，你必须在几秒内响应，并完成「验证—解析—去重」这一套，再把消息转成自己内部统一的格式。

3. **能拿到飞书发消息的「门票」**  
   飞书 API 需要先拿 Token，再拿着 Token 去发回复。Token 有过期时间，所以要带缓存、到期再换。

4. **收到消息后，直接调一次大模型**  
   第一天不搞队列、不搞多轮会话历史，就「用户一句话 → 调一次大模型 → 把回复通过飞书 API 发回去」。先跑通这条最短路。

所以「第一天」的完成标准就是：  
在飞书里发「你好」，机器人能在几秒内回你一句正常的话；本地用 `bun run dev` 能稳定跑起来，用 PM2 也能正常守护；飞书开放平台里配置好 Webhook 后，验证能通过。

---

## 四、第一天我具体做了哪些事

### 1. 把项目骨架搭好

用 Bun 初始化了项目，配好了 TypeScript 和基础依赖：Hono 做 HTTP、Zod 做校验、Anthropic 的 SDK 用来调 Claude，再加一个 pino 打日志。配置文件拆成 `config.yaml` 和 `.env`，敏感信息不放代码里。同时写好了 PM2 的配置，方便以后一键启动和守护进程。

### 2. 做好「大门」：Gateway 层

所有从飞书来的请求，都先经过 Gateway。这里做了几件事：

- **Challenge 验证**  
  飞书第一次配置 Webhook 时会发一个验证请求，你必须原样把里面的 `challenge` 填回去，飞书才认为你这个地址是合法的。这一步不通过，后面都白搭。

- **签名校验**  
  每个请求都带签名，服务器要验一遍，防止别人伪造「飞书发来的消息」。

- **幂等去重**  
  飞书可能因为网络问题对同一条消息重试推送，所以用「事件 ID」做了个小缓存，同一 ID 只处理一次，避免用户说一句「你好」机器人回三遍。

- **消息归一化**  
  飞书的事件格式和内部逻辑需要的格式不一样，所以专门写了一个「归一化」步骤：把飞书的事件转成统一的「谁、在哪个会话、发了什么文本」这样的结构，后面所有模块都只认这一种格式，不用再关心飞书长什么样。

### 3. 飞书 API 封装

要回复用户，就必须调飞书的接口。飞书要求先拿「租户访问令牌」（Token），再在发消息时带上。Token 有两小时有效期，所以做了简单缓存：在过期前重复用同一个，过期后再重新申请。封装了「拿 Token」和「按消息 ID 回复」两个能力，这样业务层只需要说「回复这条消息，内容是什么」即可。

### 4. 最简的「大脑」：收到消息就调 LLM

第一天没有上队列、没有会话历史、没有人格和技能，就是：  
收到一条归一化后的用户消息 → 直接调 Claude API（单模型、单 Key）→ 拿到回复文本 → 用飞书 API 发回去。

这样做的目的就是把整条链路打通：从「用户在飞书里打字」到「大模型生成回复」再到「用户看到回复」，中间没有断点。只有这一步稳了，后面加会话、加工具、加记忆才有意义。

### 5. 本地调试和飞书配置

用内网穿透（例如 ngrok）把本机端口暴露到公网，在飞书开放平台里把 Webhook 地址填进去，订阅「接收消息」类事件。保存配置时飞书会发 Challenge，我们正确回包后，飞书就会开始往这个地址推真实消息。这样在本地就能用真实飞书账号和机器人对话，验证「发一句，回一句」的完整流程。

---

## 五、一点感受

第一天做完之后，我在飞书里发「你好」，机器人真的回了一句正常的话。虽然还没历史、没工具、没人设，但**「从渠道进、经大模型、再回渠道」**这条主脉已经通了。

这让我更确信两件事：

一是 **OpenClaw 所代表的「个人自托管 Agent + 多渠道 + 真干活」这个方向，值得当成一个长期命题来做**。它可能不会马上改变所有人，但会先改变像我们这样愿意自己搭、自己控的人的工作方式，再慢慢扩散。我愿意把这件事当成自己的「iPhone 时刻」来押注。

二是 **复刻的意义不在于抄代码，而在于把设计想清楚、把链路走通**。第一天只做了最小闭环，但已经涉及：渠道接入、鉴权、归一化、模型调用、回复下发。后面要加的会话、队列、人格、工具、记忆，都是在这条闭环上「加层」，而不是推倒重来。

如果你也在做 Agent 或对「自己能完全掌控的 AI 助理」感兴趣，欢迎一起交流。接下来我会按计划一天天把会话、人格、工具、记忆和稳定性都补上，目标是在飞书里有一个真正好用、可迭代的个人助理。

---

*第一天，主脉已通。*
